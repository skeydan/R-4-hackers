```{r setup, include=FALSE}
opts_chunk$set(cache=TRUE)
opts_chunk$set(out.width='700px', dpi=200)
opts_chunk$set(fig.align='left')
library(ggplot2)
library(GGally)
library(dplyr)
```
<style>
 
.reveal pre code {
  font-size: 1em;
}
.midcenter {
    position: fixed;
    top: 50%;
    left: 50%;
}
.footer {
    position: fixed; 
    top: 90%;
    text-align:right; 
    width:90%;
    margin-top:-150px;
}
.reveal section img {
  border: 0px;
  box-shadow: 0 0 0 0;
}
</style>


R 4 hackers
========================================================
author: 
date: 
autosize: true 
width: 1440
incremental:true 

Hello World
========================================================

&nbsp;

... that is, _Data Science Hello World_.



We have some data!
========================================================

&nbsp;

Sure, first we do data exploration ...

```{r}
data(longley)
head(longley)
```


Sure, we visualize...
========================================================

&nbsp;

```{r}
ggpairs(longley)
```


And then: Hello World
========================================================

&nbsp;

Linear models.

&nbsp;  

```{r}
fit <- lm(Employed ~ GNP, longley)
```

&nbsp;

Now what can we do with this thing returned by lm?


Print it
========================================================

&nbsp;

```{r}
# equivalently: print(fit)
fit
```


Output a summary
========================================================

&nbsp;

```{r}
summary(fit)
```


Use it to make predictions
========================================================

&nbsp;

```{r}
predict(fit, newdata = data.frame(GNP = c(222, 223)))
```


We can plot it...
========================================================

&nbsp;

```{r}
par(mfrow=c(2,2))
plot(fit)
par(mfrow=c(1,1))
```


... and even do some fancy stuff 
========================================================

&nbsp;

... like extracting the Akaike Information Criterion

```{r}
extractAIC(fit)
```

&nbsp;

Let's see what other objects we can print, plot, get a summary of! 


Data frames
========================================================

&nbsp;

```{r}
df <- data.frame(x = 1:8, y = cumsum(rnorm(8)))
df
summary(df)
```


Data frames
========================================================

&nbsp;

```{r}
plot(df)
```


Time series objects
========================================================

&nbsp;

```{r}
ts <- ts(cumsum(round(rnorm(120), 2)), start = c(2004,12), frequency = 12)
ts
summary(ts)
```


Time series objects
========================================================

&nbsp;

```{r}
plot(ts)
```


Things we can get a summary of (but not plot) ...
========================================================

&nbsp;

```{r}
m <- matrix(1:10, nrow = 2)
summary(m)
```

Things we can plot (but not get a summary of)
========================================================

&nbsp;

```{r}
plot(function(x) x^2, from = -2, to = 2)
```


What is going on?
========================================================

&nbsp;

- R has several OO systems (on top of base (internal) objects)
- the oldest and most widely used is S3


S3 
========================================================

&nbsp;

- generic function OO (instead of the more common message-passing OO)
- methods belong to (generic) functions, not to classes!
- _UseMethod()_ performs method dispatch

```{r}
print 
```

```{r}
UseMethod
```


In S3, there are no formal class definitions
========================================================

&nbsp;

```{r} 
# create an instance of class bike
# a bike constructor
bike <- function(type, color) {structure (list(type = type, color = color), class = 'bike')}
mybike <- bike('cyclocross', 'green')
class(mybike) 
```

```{r} 
# still prints like a list
mybike 
```

```{r} 
# define print for bikes
print.bike <- function(b) {print(paste0('a rolling thing with ', b$numwheels, ' wheels and ', b$numhandlebars, ' handle bar'))}
mybike
```


In S3, there are no formal class definitions
========================================================

&nbsp;

```{r} 
# what if we just change the class
class(mybike) <- 'lm'
# and then print it
mybike
```


S3 "inheritance" is informal as well
========================================================

```{r} 
# create an instance of class bike
theotherpersonsbike <- structure(list(motor = 1), class = c('e-bike', 'bike'))
class(theotherpersonsbike) 
```



The magic three: map, fold, and filter
========================================================

- function in, data out
- ```map```: map a function over a list of elements
    - in Haskell:

```
λ: map (+1) [1..10]
[2,3,4,5,6,7,8,9,10,11]
```

- ```filter```: filter a list of elements according to some predicate
    - in Haskell:

```
λ: filter even [1..10]
[2,4,6,8,10]
```

- ```fold```: combine values recursively
    - in Haskell:

```
λ: foldl (+) 0 [1..10]
55
```
a.k.a. reduce (Clojure, Java, Python...), apply (Scheme, ...)


Mapping in R: meet the family
========================================================

- apply, lapply, sapply, vapply, mapply, tapply ... ough
- What data structure(s) am I working with?
    - one-dimensional?
    - more than one dimension?
    - more than one data structure?


The apply family (1): just apply 
========================================================

Use with more-than-one-dimensional data structures
    - data.frame
    - matrix
    - array
   
```{r}
data("women")
# apply mean to the dataframe's columns 
apply(women, 2, mean)
```

```{r}
m <- matrix(1:12, nrow = 3, ncol = 4)
m
# apply mean to the rows
apply(m, 1, mean)
```


The apply family (2): lapply and friends
========================================================

Use with one-dimensional stuff (list, vector)

But which of [s|l|t]apply?

lapply: outputs a list

```{r}
mychars <- c("a", "b", "c")
str(lapply(mychars, toupper))
```

sapply: simplifies the result

```{r}
mychars <- c("a", "b", "c")
str(sapply(mychars, toupper))
```

vapply: returns requested type

```{r}
mychars <- c("a", "b", "c")
str(vapply(mychars, as.integer, integer(1)))
```


What's the problem with sapply?
========================================================



Object types: class(), typeof(), mode() ... oh my!
========================================================


Just wanna use R? Use _class()_:

```{r}
myfunc <- function(x) x + 1
tests1 <- c(`<-`, `if`, `[`, length, c, sum, nrow, eval, myfunc)
sapply(tests1, class)
```

For the user, these are all _functions_.
Even though they do such different things as

- assignment (x <- 1)
- constructing new objects (x <- c(1,2))
- branching (if)


typeof() tells about the internal object type:
========================================================

```{r}
tests1 <- c(`<-`, `if`, `[`, length, c, sum, nrow, eval, myfunc)
sapply(tests1, typeof)
```

So we have three different corresponding object types:

- specials,
- builtins, and
- closures.


Closures (1)
========================================================

Every user-defined function will be a closure.

With closures, we can conveniently print the source code on the console:

```{r}
nrow
```


Closures (2)
========================================================

Closures have formals, a body, and an associated environment.

```{r}
c(formals(myfunc), body(myfunc), environment(myfunc))
```


Let's try this with eval!
========================================================

```{r}
formals(eval)
```

```{r}
body(eval)
```

Oops!

####TBD###
# eval = .Internal(eval(expr, envir, enclos))
# .Internal = built into the R interpreter
# names.c ---> show how lookup table looks...
# eval.c show eval function!

